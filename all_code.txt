# Digital Twin Profile - Code Complete
# Mis à jour le: 2026-02-04

================================================================================
FILE: lib/crypto/zk-encryption.ts
================================================================================
// Fix build dependencies Vercel
/**
 * Zero-Knowledge Encryption Module
 * 
 * Implements AES-256-GCM encryption with PBKDF2 key derivation.
 * All encryption happens client-side. The server never sees the encryption key.
 */

import { pbkdf2 } from '@noble/hashes/pbkdf2.js';
import { sha256 } from '@noble/hashes/sha2.js';

const PBKDF2_ITERATIONS = 100000;
const SALT_LENGTH = 32;
const IV_LENGTH = 12; // GCM standard IV length
const KEY_LENGTH = 32; // 256 bits

/**
 * Derives an encryption key from a master password using PBKDF2
 */
export async function deriveKey(
  masterPassword: string,
  salt: Uint8Array
): Promise<CryptoKey> {
  // Use PBKDF2 to derive key material
  const keyMaterial = pbkdf2(sha256, masterPassword, salt, {
    c: PBKDF2_ITERATIONS,
    dkLen: KEY_LENGTH,
  });

  // Import the key material as a CryptoKey for Web Crypto API
  // Create a new Uint8Array to ensure proper ArrayBuffer type
  return await crypto.subtle.importKey(
    'raw',
    new Uint8Array(keyMaterial),
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

/**
 * Generates a cryptographically secure random salt
 */
export function generateSalt(): Uint8Array {
  return crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
}

/**
 * Generates a cryptographically secure random IV
 */
export function generateIV(): Uint8Array {
  return crypto.getRandomValues(new Uint8Array(IV_LENGTH));
}

/**
 * Encrypts data using AES-256-GCM
 */
export async function encrypt(
  data: string,
  key: CryptoKey
): Promise<string> {
  const iv = generateIV();
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);

  const encryptedBuffer = await crypto.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv: new Uint8Array(iv),
    },
    key,
    dataBuffer
  );

  const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
  combined.set(iv, 0);
  combined.set(new Uint8Array(encryptedBuffer), iv.length);

  return btoa(String.fromCharCode.apply(null, Array.from(combined)));
}

/**
 * Decrypts data encrypted with AES-256-GCM
 */
export async function decrypt(
  encryptedData: string,
  key: CryptoKey
): Promise<string> {
  try {
    const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
    const iv = combined.slice(0, IV_LENGTH);
    const encryptedBuffer = combined.slice(IV_LENGTH);

    const decryptedBuffer = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(iv),
      },
      key,
      encryptedBuffer
    );

    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  } catch (error) {
    throw new Error('Decryption failed: Invalid key or corrupted data');
  }
}

/**
 * Hashes a master password to create a verification hash
 */
export function hashPassword(password: string, salt: Uint8Array): string {
  const hash = pbkdf2(sha256, password, salt, {
    c: PBKDF2_ITERATIONS,
    dkLen: 32,
  });
  return btoa(String.fromCharCode.apply(null, Array.from(hash)));
}

/**
 * Verifies a password against a stored hash
 */
export function verifyPassword(
  password: string,
  salt: Uint8Array,
  storedHash: string
): boolean {
  const computedHash = hashPassword(password, salt);
  return computedHash === storedHash;
}

/**
 * Encrypts an object by converting it to JSON first
 */
export async function encryptObject<T>(
  obj: T,
  key: CryptoKey
): Promise<string> {
  const json = JSON.stringify(obj);
  return await encrypt(json, key);
}

/**
 * Decrypts an encrypted object
 */
export async function decryptObject<T>(
  encryptedData: string,
  key: CryptoKey
): Promise<T> {
  const json = await decrypt(encryptedData, key);
  return JSON.parse(json) as T;
}

/**
 * Converts a Uint8Array to a base64 string for storage
 */
export function arrayToBase64(array: Uint8Array): string {
  return btoa(String.fromCharCode.apply(null, Array.from(array)));
}

/**
 * Converts a base64 string back to a Uint8Array
 */
export function base64ToArray(base64: string): Uint8Array {
  return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
}

================================================================================
FILE: lib/crypto/key-manager.ts
================================================================================
/**
 * Key Manager - Secure Session-Based Key Storage
 */

import { deriveKey, generateSalt, arrayToBase64, base64ToArray } from './zk-encryption';

interface KeySession {
    masterKey: CryptoKey;
    profileId: string;
    salt: Uint8Array;
    createdAt: number;
    lastAccessedAt: number;
}

class KeyManager {
    private session: KeySession | null = null;
    private readonly AUTO_LOCK_TIMEOUT = 30 * 60 * 1000; // 30 minutes

    async initializeSession(
        profileId: string,
        masterPassword: string,
        salt: Uint8Array
    ): Promise<void> {
        const masterKey = await deriveKey(masterPassword, salt);

        this.session = {
            masterKey,
            profileId,
            salt,
            createdAt: Date.now(),
            lastAccessedAt: Date.now(),
        };
    }

    getMasterKey(): CryptoKey {
        this.checkSession();
        this.session!.lastAccessedAt = Date.now();
        return this.session!.masterKey;
    }

    getProfileId(): string {
        this.checkSession();
        return this.session!.profileId;
    }

    getSalt(): Uint8Array {
        this.checkSession();
        return this.session!.salt;
    }

    isSessionActive(): boolean {
        if (!this.session) return false;

        const timeSinceLastAccess = Date.now() - this.session.lastAccessedAt;
        if (timeSinceLastAccess > this.AUTO_LOCK_TIMEOUT) {
            this.lockSession();
            return false;
        }

        return true;
    }

    lockSession(): void {
        this.session = null;
    }

    async deriveSpecializedKey(purpose: string): Promise<CryptoKey> {
        this.checkSession();

        const purposeBuffer = new TextEncoder().encode(purpose);
        const combinedSalt = new Uint8Array(this.session!.salt.length + purposeBuffer.length);
        combinedSalt.set(this.session!.salt, 0);
        combinedSalt.set(purposeBuffer, this.session!.salt.length);

        const specializedKey = await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: combinedSalt,
                iterations: 100000,
                hash: 'SHA-256',
            },
            this.session!.masterKey,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        );

        return specializedKey;
    }

    private checkSession(): void {
        if (!this.isSessionActive()) {
            throw new Error('Session expired or not initialized. Please unlock your profile.');
        }
    }

    getSessionInfo(): { profileId: string; createdAt: number; lastAccessedAt: number } | null {
        if (!this.session) return null;

        return {
            profileId: this.session.profileId,
            createdAt: this.session.createdAt,
            lastAccessedAt: this.session.lastAccessedAt,
        };
    }
}

export const keyManager = new KeyManager();

================================================================================
FILE: app/api/profile/[id]/route.ts
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const id = (await params).id;

        // On récupère uniquement les infos publiques nécessaires au déchiffrement
        const profile = await prisma.profile.findUnique({
            where: { id },
            select: {
                id: true,
                name: true,
                saltBase64: true,
                passwordHash: true, // Sert à vérifier le mot de passe client-side, pas à déchiffrer
            },
        });

        if (!profile) {
            return NextResponse.json({ error: 'Profil introuvable' }, { status: 404 });
        }

        return NextResponse.json(profile);
    } catch (error) {
        return NextResponse.json({ error: 'Erreur serveur' }, { status: 500 });
    }
}

================================================================================
FILE: app/profile/unlock/page.tsx
================================================================================
'use client';

import { useState, useEffect, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { base64ToArray, verifyPassword } from '@/lib/crypto/zk-encryption';
import { keyManager } from '@/lib/crypto/key-manager';

function UnlockContent() {
    const router = useRouter();
    const searchParams = useSearchParams();
    const id = searchParams.get('id');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [profileData, setProfileData] = useState<any>(null);

    useEffect(() => {
        if (id) {
            fetch(`/api/profile/${id}`).then(res => res.json()).then(setProfileData);
        }
    }, [id]);

    const handleUnlock = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        setError('');

        try {
            if (!profileData) throw new Error("Profil non chargé");

            const salt = base64ToArray(profileData.saltBase64);
            const isValid = verifyPassword(password, salt, profileData.passwordHash);

            if (!isValid) throw new Error("Mot de passe incorrect");

            // Initialiser la session sécurisée en mémoire
            await keyManager.initializeSession(profileData.id, password, salt);
            router.push('/dashboard'); // Redirection vers le tableau de bord
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    if (!profileData) return <div className="text-white text-center mt-20">Chargement du profil...</div>;

    return (
        <div className="min-h-screen bg-slate-900 flex items-center justify-center p-4">
            <div className="max-w-md w-full bg-white/10 backdrop-blur rounded-2xl p-8 border border-white/20">
                <h1 className="text-2xl font-bold text-white mb-2 text-center">Déverrouiller {profileData.name}</h1>
                {error && <div className="bg-red-500/20 text-red-200 p-3 rounded mb-4">{error}</div>}
                <form onSubmit={handleUnlock} className="space-y-4">
                    <input
                        type="password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        className="w-full bg-black/20 border border-purple-500/30 rounded p-3 text-white"
                        placeholder="Mot de passe maître"
                        autoFocus
                    />
                    <button disabled={loading} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded transition">
                        {loading ? 'Déchiffrement...' : 'Accéder au Jumeau'}
                    </button>
                </form>
            </div>
        </div>
    );
}

export default function UnlockPage() {
    return (
        <Suspense fallback={<div>Chargement...</div>}>
            <UnlockContent />
        </Suspense>
    );
}

================================================================================
FILE: app/dashboard/page.tsx
================================================================================
'use client';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { keyManager } from '@/lib/crypto/key-manager';

export default function Dashboard() {
    const router = useRouter();
    const [authorized, setAuthorized] = useState(false);

    useEffect(() => {
        if (!keyManager.isSessionActive()) {
            router.push('/');
        } else {
            setAuthorized(true);
        }
    }, [router]);

    if (!authorized) return null;

    return (
        <div className="min-h-screen bg-slate-900 text-white p-10">
            <h1 className="text-4xl font-bold mb-4">Bienvenue dans votre Jumeau Numérique</h1>
            <p className="text-xl text-purple-300">Session sécurisée active. Vos données sont chiffrées.</p>
            {/* Ici viendra le composant Scribe plus tard */}
        </div>
    );
}

================================================================================
FILE: prisma/schema.prisma
================================================================================
// Prisma Schema for Digital Twin Profile System
// Zero-Knowledge Architecture with Supabase pgvector

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [vector]
}

model Profile {
  id                String   @id @default(cuid())
  name              String
  saltBase64        String
  passwordHash      String
  encryptedMetadata String   @db.Text
  vectorNamespace   String   @unique
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastAccessedAt    DateTime @default(now())
  memories          Memory[]
  
  @@index([vectorNamespace])
}

model Memory {
  id                String   @id @default(cuid())
  profileId         String
  profile           Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  encryptedContent  String   @db.Text
  encryptedMetadata String   @db.Text
  embedding         Unsupported("vector(1024)")
  type              MemoryType @default(TEXT)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([profileId])
  @@index([profileId, type])
  @@index([profileId, createdAt])
}

enum MemoryType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  CONVERSATION
}

model RecoveryPhrase {
  id                String   @id @default(cuid())
  profileId         String   @unique
  encryptedPhrase   String   @db.Text
  phraseHash        String
  createdAt         DateTime @default(now())
  
  @@index([profileId])
}

================================================================================
FILE: package.json
================================================================================
{
  "name": "digital-twin-profile",
  "version": "0.1.0",
  "description": "Clone Project - Secure Digital Twin V1",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "postinstall": "prisma generate",
    "init": "node scripts/init.js",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  },
  "dependencies": {
    "@noble/hashes": "^2.0.1",
    "@prisma/client": "^5.22.0",
    "@supabase/supabase-js": "^2.39.0",
    "bip39": "^3.1.0",
    "next": "16.1.6",
    "prisma": "^5.22.0",
    "react": "19.2.3",
    "react-dom": "19.2.3"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4.0.0",
    "typescript": "^5"
  }
}
